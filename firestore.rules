rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    // Users collection - users can only access their own data
    match /users/{userId} {
      allow read: if request.auth != null && request.auth.uid == userId;
      allow read: if request.auth != null && isValidPublicRead(); // Limited public read
      allow create: if request.auth != null && request.auth.uid == userId && isValidUserData();
      allow update: if request.auth != null && request.auth.uid == userId && isValidUserUpdate();
      allow delete: if false; // Users cannot delete their accounts via client
    }

    // Profiles collection - similar to users
    match /profiles/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
      allow read: if request.auth != null; // Allow reading other profiles for battles
    }

    // Battles collection - public read, authenticated write
    match /battles/{battleId} {
      allow read: if true; // Public battles can be viewed by anyone
      allow create: if request.auth != null && isValidBattle();
      allow update: if request.auth != null && (
        // Battle creator can update
        resource.data.createdBy == request.auth.uid ||
        // Participants can join/submit performances
        isParticipantUpdate() ||
        // Users can vote
        isVoteUpdate()
      );
      allow delete: if request.auth != null && resource.data.createdBy == request.auth.uid;
    }

    // Media collection - user-owned content with enhanced validation
    match /media/{mediaId} {
      allow read: if resource.data.privacy == 'public' || 
        (request.auth != null && resource.data.userId == request.auth.uid) ||
        (request.auth != null && resource.data.privacy == 'unlisted');
      allow create: if request.auth != null && 
        request.auth.uid == request.resource.data.userId &&
        isValidMediaData();
      allow update: if request.auth != null && 
        request.auth.uid == resource.data.userId &&
        isValidMediaUpdate();
      allow delete: if request.auth != null && 
        (request.auth.uid == resource.data.userId || isAdmin());
    }

    // AI Judgments - controlled access with validation
    match /ai_judgments/{judgmentId} {
      allow read: if request.auth != null && (
        isParticipantInBattle(resource.data.battleId) ||
        resource.data.isPublic == true
      );
      allow create: if request.auth != null && isValidAIJudgment();
      allow update: if false; // AI judgments are immutable
      allow delete: if request.auth != null && isAdmin();
    }

    // Chat messages - battle participants and spectators with rate limiting
    match /chat_messages/{messageId} {
      allow read: if request.auth != null && isParticipantInBattle(resource.data.battleId);
      allow create: if request.auth != null && 
        isValidChatMessage() && 
        isParticipantInBattle(request.resource.data.battleId) &&
        !isRateLimited();
      allow update: if false; // Chat messages are immutable
      allow delete: if request.auth != null && (
        resource.data.userId == request.auth.uid || isAdmin()
      );
    }

    // Moderation queue - admin only
    match /moderation_queue/{itemId} {
      allow read, write: if request.auth != null && isAdmin();
    }

    // Notifications - user-specific
    match /notifications/{notificationId} {
      allow read, write: if request.auth != null && 
        resource.data.userId == request.auth.uid;
    }

    // Helper functions
    function isValidBattle() {
      return request.resource.data.keys().hasAll(['title', 'createdBy', 'status', 'participants']) &&
        request.resource.data.createdBy == request.auth.uid &&
        request.resource.data.participants.size() <= 10 &&
        request.resource.data.title.size() <= 100;
    }

    function isParticipantUpdate() {
      let isParticipant = request.auth.uid in resource.data.participants;
      let isJoining = request.auth.uid in request.resource.data.participants && 
        !(request.auth.uid in resource.data.participants);
      return isParticipant || isJoining;
    }

    function isVoteUpdate() {
      // Check if only votes array is being updated
      let changedFields = resource.data.diff(request.resource.data).changedKeys();
      return changedFields.hasOnly(['votes']) && 
        request.resource.data.votes.size() > resource.data.votes.size();
    }

    function isValidChatMessage() {
      return request.resource.data.keys().hasAll(['battleId', 'userId', 'message', 'timestamp']) &&
        request.resource.data.userId == request.auth.uid &&
        request.resource.data.message.size() <= 500;
    }

    function isAdmin() {
      // In production, check custom claims or admin collection
      return request.auth.token.admin == true;
    }

    // Enhanced validation functions
    function isValidPublicRead() {
      // Only allow reading basic public profile info
      return true; // Can be restricted to specific fields in production
    }

    function isValidUserData() {
      let data = request.resource.data;
      return data.keys().hasAll(['email', 'username', 'displayName', 'createdAt']) &&
        data.email == request.auth.token.email &&
        data.username is string && data.username.size() >= 3 && data.username.size() <= 30 &&
        data.displayName is string && data.displayName.size() >= 1 && data.displayName.size() <= 50;
    }

    function isValidUserUpdate() {
      let data = request.resource.data;
      let existingData = resource.data;
      // Prevent modification of critical fields
      return data.email == existingData.email &&
        data.createdAt == existingData.createdAt &&
        (!data.diff(existingData).affectedKeys().hasAny(['email', 'createdAt', 'uid']));
    }

    function isValidMediaData() {
      let data = request.resource.data;
      return data.keys().hasAll(['title', 'userId', 'privacy', 'category', 'uploadedAt']) &&
        data.title is string && data.title.size() >= 1 && data.title.size() <= 100 &&
        data.privacy in ['public', 'private', 'unlisted'] &&
        data.category in ['battle', 'cypher', 'freestyle', 'practice', 'other'] &&
        (!data.keys().hasAny(['tags']) || data.tags.size() <= 10);
    }

    function isValidMediaUpdate() {
      let data = request.resource.data;
      let existingData = resource.data;
      // Prevent modification of critical fields
      return data.userId == existingData.userId &&
        data.uploadedAt == existingData.uploadedAt &&
        (!data.diff(existingData).affectedKeys().hasAny(['userId', 'uploadedAt']));
    }

    function isValidAIJudgment() {
      let data = request.resource.data;
      return data.keys().hasAll(['battleId', 'participantId', 'scores', 'createdAt']) &&
        data.battleId is string &&
        data.participantId is string &&
        data.scores is map &&
        data.createdAt is timestamp;
    }

    function isParticipantInBattle(battleId) {
      // Check if user is participant in the specified battle
      let battle = get(/databases/$(database)/documents/battles/$(battleId));
      return request.auth.uid in battle.data.participants;
    }

    function isRateLimited() {
      // Simple rate limiting - in production, use more sophisticated logic
      return false; // Implement rate limiting logic here
    }
  }
}